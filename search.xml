<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[item2+oh-my-zsh打造你的终端]]></title>
    <url>%2Fblog%2Fposts%2F4109537215.html</url>
    <content type="text"><![CDATA[前置准备工作HomeBrew安装Homebrew很简单,执行下面的命令即可,更多信息可查看 Homebrew官网 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 中间可能需要你确认安装,输入密码等. 还有一个是否需要安装command Line Tools的操作,如果你的电脑还没有安装,可用点击确认直接安装,这样就省了下一步再手动安装command Line Tools 了 Xcode或者command Line Tools如果已经安装了Xcode,那么启动一次Xcode会自动将Command Line Tools安装好,如果没有安装Xcode,也不想安装的(毕竟Xcode比较大),可以单独安装Command LIne Tools. 安装Command Line Tools,运行下列命令,会弹出一个弹窗,点击安装即可 1xcode-select --install Gitgit安装可用使用Homebrew,也可以 Git官网下载安装包安装,Homebrew方式直接运行下面命令即可 1brew install git 查看git版本,出现下面的输出表示git已经安装好了 12yuan@yuan-MacBook-Pro ~ % git versiongit version 2.21.0 (Apple Git-122.2) 安装iTerm2 iTerm官网 下载安装ITerm2 将系统默认的bash切换为zsh 1chsh -s /bin/zsh 如果想要切换回默认bash,运行下面命令 1chsh -s /bin/bash 查看当前可用的所有shell 12345678910111213&gt; yuan@yuan-MacBook-Pro ~ % cat /etc/shells&gt; # List of acceptable shells for chpass(1).&gt; # Ftpd will not allow users to connect who are not using&gt; # one of these shells.&gt; &gt; /bin/bash&gt; /bin/csh&gt; /bin/dash&gt; /bin/ksh&gt; /bin/sh&gt; /bin/tcsh&gt; /bin/zsh&gt; 关于iTerm的用法和设置这里不多介绍,可以在iTerm2 -&gt; Preferences -&gt; Profiles 里进行设置,字体/背景色/背景图片/窗口大小…. 具体的可以根据官网介绍来进行. 安装oh-my-zshoh-my-zsh官网 注意:oh-my-zsh是对zsh的包装,所以zsh是必须的,如果没有安装,可参照官网示例进行安装 https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH 安装oh-my-zsh有2种方方式,curl 和 wget, 任选一种即可 curlwget1sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;1sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot; 安装完成出现下面的提示 注意: 大多数情况下,我们的环境变量配置用的是~/.bash_profile文件.使用oh-my-zsh的话,配置加载的是~/.zshrc,所有需要在~/.zshrc 文件里导入~/.bash_profile,不然~/.bash_profile里配置的环境变量无法加载 主题配置oh-my-zsh有许多主题,可到 https://github.com/ohmyzsh/ohmyzsh/wiki/Themes 和 https://github.com/ohmyzsh/ohmyzsh/tree/master/themes/ 查看所有的主题, 个人使用的是ys,比较火的也有像agnoster,选择一款自己喜欢的就行 编辑用户根目录下的.zshrc文件.修改ZSH_THEME的值为对应主题即可 修改完.zshrc之后,需要刷新配置文件才能使之生效.运行 source .zshrc 命令即可,后续插件安装也是同样的,修改完配置文件后.运行命令才能看到效果 插件安装oh-my-zsh有许多插件,安装几款好用的插件能大大提高工作效率,下面介绍几个比较常用的插件. 可到 https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins 查询所有可用插件.根据每个插件的README可以知道每个插件的功能.有兴趣的小伙伴可以自己研究发现更多有趣的功能. 命令补全它会根据历史记录和完成情况建议输入的命令,.详情查看 GitHub地址 安装:运行命令会将插件clone到本地的~/.oh-my-zsh/custom/plugins下 1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 配置:修改.zshrc文件,找到plugins,加入zsh-autosuggestions,刷新配置文件 source .zshrc 1plugins=(zsh-autosuggestions) 用法:输入命令时，会在光标后看到灰色的静音形式的补全.如果是你想要输入的命令.按方向右键→即可. 例如.我第一次输入cd work/application 到目录中.下次我输入cd时.可以看到后面有灰色的提示,这时按→即可补全命令 有时由于背景颜色或主题的影响,导致自动补全提示肯不清楚,可以通过修改配置.oh-my-zsh/custom/plugins/zsh-autosuggestions/src/config.zsh中的ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE来调节.官方文档也有介绍.不过比较麻烦.使用iTerm的话.有一个比较简单的方法,修改 Preferences -&gt; Profiles -&gt; Colors 中有Foreground是标准字体颜色,ANSI Colors中Bright的第一个是补全的字体颜色即可 高亮提示提供了语法高亮显示,当命令在zsh提示符下键入到交互式终端时,它可以突出显示命令.这有助于在运行命令之前对其进行检查,尤其是在捕获语法错误时. 详情查看 GitHub地址 安装:运行命令会将插件clone到本地的~/.oh-my-zsh/custom/plugins下 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 配置:修改.zshrc文件,找到plugins,加入zsh-syntax-highlighting,刷新配置文件 source .zshrc 1plugins=(zsh-syntax-highlighting) 用法: 高亮提示会提示命令的正确性,安装完成之后.我们随便打一个命令,可以看到命令是红色的,说明这个命令是错误的.输入一个正确的命令.可以看到命令是绿色的. 自动跳转(autojump)自动跳转是可以更快速的进行目录间切换跳转的插件.通过记录你之前进入的目录历史,可以更加快速简便的访问目录. 详情查看 Github地址 安装:运行 brew install autojump 配置: 修改.zshrc文件,找到plugins,加入autojump,刷新配置文件 source .zshrc 1plugins=(autojump) 用法: 安装好autojump后. 比如我们进入一个目录aa/bb/cc,然后回到用户根目录,想再次进入刚才的目录的话. 只需要运行 j cc即可跳转到 aa/bb/cc这个目录了.]]></content>
      <categories>
        <category>spring zsh</category>
      </categories>
      <tags>
        <tag>oh-my-zsh</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 存储功能]]></title>
    <url>%2Fblog%2Fposts%2F1021748748.html</url>
    <content type="text"><![CDATA[有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 git stash 命令 git stash 存储有时,当你在项目的一部分上已经工作一段时间后,所有东西都进入了混乱的状态,而这时你想要切换到另一个分支做一点别的事情. 问题是,你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交; gti stash可以很好的解决这个问题. 使用git stash可以将当前工作区的修改存储到栈上,让工作目录变成干净的.这样你就可以进行其他切换分支的操作了. 运行git status 查看当前有一个修改了的文件 123456789101112$ git status On branch masterYour branch is ahead of 'origin/master' by 4 commits. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: a.txtno changes added to commit (use "git add" and/or "git commit -a") 存储运行 git stash 或者 git push将修改存储到栈上 12$ git stashSaved working directory and index state WIP on master: 4034fbc devdev 选项: -u : 默认情况下,stash不会存储未跟踪文件.使用-u可以将未跟踪文件也存储 12345678910111213141516171819202122232425262728&gt; $ git status ## 有一个b.txt是新加文件.还没有被git跟踪&gt; On branch master&gt; Your branch is ahead of 'origin/master' by 4 commits.&gt; (use "git push" to publish your local commits)&gt; &gt; Untracked files:&gt; (use "git add &lt;file&gt;..." to include in what will be committed)&gt; &gt; b.txt&gt; &gt; nothing added to commit but untracked files present (use "git add" to track)&gt; &gt; # yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:master x [14:06:40]&gt; $ git stash ## stash时不会存储b.txt&gt; No local changes to save&gt; &gt; # yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:master x [14:06:47]&gt; $ git stash -u ## 加上-u 后可以存储b.txt&gt; Saved working directory and index state WIP on master: 4034fbc devdev&gt; &gt; # yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:master o [14:06:58]&gt; $ git status ## 工作空间干净了&gt; On branch master&gt; Your branch is ahead of 'origin/master' by 4 commits.&gt; (use "git push" to publish your local commits)&gt; &gt; nothing to commit, working tree clean&gt; --keep-index : 它告诉 Git 不要储藏任何你通过 git add 命令已暂存的东西.即已暂存的文件不会被存储到栈上 1234567891011121314151617181920212223242526272829303132&gt; $ git status ##有2个文件修改.但是a.txt状态是已暂存,README.md是已修改未暂存&gt; On branch master&gt; Your branch is ahead of 'origin/master' by 4 commits.&gt; (use "git push" to publish your local commits)&gt; &gt; Changes to be committed:&gt; (use "git reset HEAD &lt;file&gt;..." to unstage)&gt; &gt; modified: a.txt&gt; &gt; Changes not staged for commit:&gt; (use "git add &lt;file&gt;..." to update what will be committed)&gt; (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)&gt; &gt; modified: README.md&gt; &gt; &gt; # yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:master x [14:13:48]&gt; $ git stash --keep-index ##通过--keep-index选项不存储已暂存的文件&gt; Saved working directory and index state WIP on master: 4034fbc devdev&gt; &gt; # yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:master x [14:13:57]&gt; $ git status ## 再次查看,可以看到a.txt的修改还可以看到&gt; On branch master&gt; Your branch is ahead of 'origin/master' by 4 commits.&gt; (use "git push" to publish your local commits)&gt; &gt; Changes to be committed:&gt; (use "git reset HEAD &lt;file&gt;..." to unstage)&gt; &gt; modified: a.txt&gt; 再次查看状态,可以看到工作目录已经干净了.此时你可以做你想做的其他任何事情了. 123456$ git statusOn branch masterYour branch is ahead of 'origin/master' by 4 commits. (use "git push" to publish your local commits)nothing to commit, working tree clean 查看存储列表运行 git stash list 可以查看存储在栈上的修改记录 123$ git stash liststash@&#123;0&#125;: WIP on master: 4034fbc devdev(END) 存储恢复当你做完了其他事情.需要继续之前的工作是.需要将存储在栈上的修改还原到工作目录. 使用git stash apply 即可,可以看到之前的修改回来了 123456789101112$ git stash applyOn branch masterYour branch is ahead of 'origin/master' by 4 commits. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: a.txtno changes added to commit (use "git add" and/or "git commit -a") 当你有多个存储记录时.你也可以选择应用之前的任意存储.只需加上存储的名字指定即可 如我这里有2个存储记录 stash@{0}: WIP on master: 4034fbc devdevstash@{1}: WIP on master: 4034fbc devdev 如果直接使用git stash apply.默认还原的是最新放入栈中存储记录.即stash@{0},要还原之前的存储.使用 git stash apply stash@{1}即可 12345678910111213$ git stash apply stash@&#123;1&#125;On branch masterYour branch is ahead of 'origin/master' by 4 commits. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.md modified: a.txtno changes added to commit (use "git add" and/or "git commit -a") git stash pop 和 git stash apply效果类似.不过恢复工作空间的同时会将栈中的存储记录删除.而apply不会.存储记录会一直存在 12345678910111213$ git stash popOn branch masterYour branch is ahead of 'origin/master' by 4 commits. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: a.txtno changes added to commit (use "git add" and/or "git commit -a")Dropped refs/stash@&#123;0&#125; (dccf2611119454d1a941c94c45de9803686f5a4a) 删除存储记录当你不想要存储记录或者是某次存储已经通过git stash apply恢复了. 想要删除存储列表中的记录是.可以通过 git stash drop &lt;name&gt; 删除 12$ git stash drop stash@\&#123;1\&#125;Dropped stash@&#123;1&#125; (f61b36e10011f53f242da45cc2142fe7fc99f18e) 当你想清空所有的存储记录是.可以使用git stash clear ,慎用(除非你确定所有的存储都不再被需要) 1$ git stash clear 从存储记录检出一个分支可以基于某个存储记录检出一个分支用于工作. 123456789101112131415$ git stash branch tempBranch stash@\&#123;1\&#125;Switched to a new branch 'tempBranch'On branch tempBranchChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: a.txtChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdDropped stash@&#123;1&#125; (f05f2e14adfd6590bfb682029432d9f7d5024d0d) git clean 清理可以使用 git clean 命令去除冗余文件或者清理工作目录, 使用 git clean -f -d 命令来移除工作目录中所有未追踪的文件以及空的子目录 123456789101112131415161718192021222324252627282930313233343536$ git status ###工作目录中有1个新加文件.1个已暂存文件.1个已修改未暂存文件On branch tempBranchChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: a.txtChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) b.txt# yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:tempBranch x [14:30:38]$ git clean -d -f ### git clean 会清除未跟踪文件.即b.txtRemoving b.txt# yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:tempBranch x [14:30:53]$ git statusOn branch tempBranchChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: a.txtChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.md]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git stash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git修改历史及版本回退]]></title>
    <url>%2Fblog%2Fposts%2F3012424038.html</url>
    <content type="text"><![CDATA[许多时候,在使用 Git 时,可能会因为某些原因想要修正提交历史.比较常见的是修改最后一次提交和压缩多次提交记录. 修改最后一次提交有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了. 此时,可以运行带有 --amend 选项的提交命令尝试重新提交 1$ git commit --amend 这个命令会将暂存区中的文件提交.如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息. 压缩提交有时.我们的提交记录里有很多次提交,当我们要把本地的分支提交到远程仓库或是合并到主分支时.太多了提交记录会影响主分支的简洁.所有可能需要将多个提交记录压缩成一次提交. 通过git log 查看本地分支的提交记录.现在我需要将下面的提交记录压缩成2次提交,即把最后6次提交压缩成1次 12345678$ git log --oneline47bdbe0 (HEAD -&gt; tempBranch) amend change log64a74db mastermaster81e5a70 add b.txt81fa084 add line to a.txtd61e878 (origin/master, origin/HEAD) test update11b7fa8 (tag: v1.0) test commit9ef1783 Initial commit 运行 git rebase -i HEAD~6 会进入一个交互界面,下面列出了进6次提交的记录,这是按照提交时间升序排列的,上面的是比较旧的提交记录,从第二行开始将pick改为s或者squash,表示将后5次提交记录压缩进11b7fa8这个提交记录 1$ git rebase -i HEAD~6 123456pick 11b7fa8 test commits d61e878 test updates 81fa084 add line to a.txts 81e5a70 add b.txts 64a74db mastermasters 47bdbe0 amend change log 改好之后Esc --&gt; :wq 保存退出.会进入另一个交互界面.这个界面是用来重写提交message的.同样的.将message改好之后保存退出就完成了. 12345[detached HEAD 00d8e37] squash commit Date: Fri Nov 1 17:18:59 2019 +0800 1 file changed, 3 insertions(+) create mode 100644 a.txtSuccessfully rebased and updated refs/heads/tempBranch. 此时查看git 提交记录可以看到.提交记录已经压缩完成了 123$ git log --oneline00d8e37 (HEAD -&gt; tempBranch) squash commit9ef1783 Initial commit 更简单的压缩如果只是需要将多次提交记录压缩的话.可以使用 git reset --soft “HEAD~n”压缩,然后使用git commit --amend修改提交信息.就可以达到和上面多次squash和pick一样的效果 下面是例子有3次提交记录,我们现在将其压缩成1个提交记录. 1234$ git log --onelined61e878 (HEAD -&gt; master, origin/master, origin/HEAD) test update11b7fa8 (tag: v1.0) test commit9ef1783 Initial commit 运行 git reset --soft &quot;HEAD~2” 压缩 1$ git reset --soft "HEAD~2" 此时查看提交记录,只有一个了 12$ git log --oneline9ef1783 (HEAD -&gt; master) Initial commit 使用 git commit –amend修改提交信息 1234567$ git commit --amend[master 1249328] update commit Author: jianxin.yuan &lt;53457400+jianxin-yuan@users.noreply.github.com&gt; Date: Fri Nov 1 15:37:35 2019 +0800 2 files changed, 3 insertions(+) create mode 100644 README.md create mode 100644 a.txt 此时再查看提交记录,只有一次提交记录,提交信息也是我们希望看到的了 121249328 (HEAD -&gt; master) update commit(END) 这里实际是运用版本回退功能回退到了2个提交之前.然后通过修改提交信息来实现压缩的 版本回退版本回退有git reset 和 git revert 2种方法,git reset 是真正的版本回退.是将HEAD指针移到指定的版本处,而git revert 是产生一个新的提交.虽然代码回退了,但是版本依然是向前的. 使用git reset回退公共远程分支的版本后，需要其他所有人手动用远程master分支覆盖本地master分支，显然，这不是优雅的回退方法 git revert 命令 push的时候不需要强制更新,也不会影响其他人pull git revert例如:现在有一个3次提交的项目,如下 1234$ git log --onelined61e878 (HEAD -&gt; master, origin/master, origin/HEAD) test update11b7fa8 (tag: v1.0) test commit9ef1783 Initial commit 现在发现最后一次提交d61e878 有问题.需要回退到11b7fa8版本的内容. 可以使用 git revert HEAD 因为git revert 会产生一次新的提交,所以会出现这个界面.输入提交的message.保存退出 123$ git revert HEAD[master 5733a79] Revert "test update" 1 file changed, 1 deletion(-) 查看日志 12345$ git log --oneline5733a79 (HEAD -&gt; master) Revert "test update"d61e878 (origin/master, origin/HEAD) test update11b7fa8 (tag: v1.0) test commit9ef1783 Initial commit 可以看到多了一次Revert “test update” 的提交记录.同时版本的内容也已经回退到了和11b7fa8 (tag: v1.0) test commit这个版本一致 12345678910&gt; 命令说明及注意点:&gt; git revert HEAD //撤销最近一次提交&gt; git revert HEAD~1 //撤销上上次的提交，注意：数字从0开始&gt; git revert d61e878 //撤销d61e878这次提交&gt; &gt; 1. revert 是撤销一次提交，所以后面的commit id是你需要回滚到的版本的前一次提交&gt; 2. 使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的&gt; 3. 使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。&gt; 4. 如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了.&gt; git reset使用git revret 回退多个版本的时候比较麻烦.会产生冲突.所以这个时候git reset就可以出场了. git reset --soft : 表示回退到指定版本,并保持暂存区和工作目录状态,即返回对应版本git commit之前的状态. 12345678910$ git log --onelined61e878 (HEAD -&gt; master, origin/master, origin/HEAD) test update11b7fa8 (tag: v1.0) test commit9ef1783 Initial commit$ git reset --soft 11b7fa8a800ae110e9efb71efbbc4c3c45b66699 ##回退到11b7fa8$ git log --oneline11b7fa8 (HEAD -&gt; master, tag: v1.0) test commit9ef1783 Initial commit 可以看到git 回退了到了11b7fa8这个版本,同时查看status,发现暂存区有暂存文件,相当于回退到了11b7fa8版本之前,运行了git add 命令之后, git commit命令之前的一个阶段 123456789$ git statusOn branch masterYour branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use "git pull" to update your local branch)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: a.txt 此时,如果想继续回退.不要暂存区里的修改.可以使用git reset HEAD &lt;file&gt;继续回退 1234567891011121314151617181920212223242526$ git reset HEAD a.txt ##取消a.txt暂存Unstaged changes after reset:M a.txt# yuan @ yuan-jxdeMacBook-Pro in ~/work/practice/git-flow-demo on git:master x [15:02:49]$ git statusOn branch masterYour branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use "git pull" to update your local branch)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: a.txtno changes added to commit (use "git add" and/or "git commit -a")$ git checkout -- a.txt ##取消a.txt修改$ git status ##再次查看.工作目录干净了On branch masterYour branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use "git pull" to update your local branch)nothing to commit, working tree clean git reset --hard : 表示回退到指定版本.不保持暂存区和工作目录状态,相当于git reset –soft 然后再取消暂存再取消修改,和上面操作之后的结果是一样的.相当于返回对应版本,且工作目录未修改过的阶段 git reset 不带参数的效果就是 git reset –soft 后再运行取消暂存的状态.相当于返回对应版本的git add命令之前的阶段 参考: Git 工具 - 重置揭密 git版本回退的不同场景操作]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git 修改历史</tag>
        <tag>git 版本回退</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支]]></title>
    <url>%2Fblog%2Fposts%2F2055204920.html</url>
    <content type="text"><![CDATA[Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次. Git分支分支创建使用git branch &lt;branchName&gt; 创建分支 1$ git branch dev 查看分支列表使用git branch 可以查看所有分支,分支前的*表示当前所处的分支 123$ git branch* dev master 选项: -v : 查看每个分支最后一次提交 1234&gt; $ git branch -v&gt; * dev 3e910e9 add b.txt&gt; master 11b7fa8 test commit&gt; –merged:表示已合并到当前分支的分支 12&gt; $ git branch --merged&gt; –no-merged:表示还未合并到当前分支的分支 12&gt; $ git branch --no-merged&gt; 切换分支使用 git checkout &lt;branchName&gt; 切换分支 12$ git checkout devSwitched to branch 'dev' 使用git chekcout -b &lt;branchName&gt; 可以创建并切换到新分支 123&gt; $ git checkout -b test&gt; Switched to a new branch 'test'&gt; 本地分支删除使用git branch -d &lt;barnchName&gt; 删除本地分支 12$ git branch -d v1.0_testDeleted branch v1.0_test (was 11b7fa8). 当删除还未合并的分支时 -d会失败.如果确认需要删除.使用-D可以强制删除 分支合并使用git merge &lt;branchName&gt; 合并其他分支到当前分支 12345$ git merge devUpdating 79d9a49..ada313bFast-forward a.txt | 1 + 1 file changed, 1 insertion(+) 推送本地分支到远程仓库使用git push &lt;remoteName&gt; &lt;localBranch&gt;:&lt;remoteBranch&gt; 将本地分支推送到远程 12345678910111213$ git push origin dev:devEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 8 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 301 bytes | 301.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote:remote: Create a pull request for 'dev' on GitHub by visiting:remote: https://github.com/jianxin-yuan/git-flow-demo/pull/new/devremote:To https://github.com/jianxin-yuan/git-flow-demo.git * [new branch] dev -&gt; dev 如果本地分支和远程分支同名.可以直接简写git push origin dev 拉取远程仓库中有而本地仓库没有的数据使用git fetch &lt;remoteName&gt; 可以将远程仓库中有而本地仓库中没有的数据拉取下来,不会自动合并 1$ git fetch origin 基于远程跟踪分支检出一个新的本地分支使用 git checkout -b &lt;localBranch&gt; &lt;remoteName&gt;/&lt;remoteBranch&gt;可以基于远程跟踪分支检出一个本地分支 1$ git checkout -b dev origin/dev 还可以使用--track选项简写,和上面是一样的 12&gt; git checkout --track origin/dev&gt; 本地分支关联远程跟踪分支使用git branch -u &lt;remoteName&gt;/&lt;remoteBranch&gt; 可以将本地分支与远程跟踪分支关联,也可以用于修改跟踪分支 12$ git branch -u origin/devBranch 'test' set up to track remote branch 'dev' from 'origin'. --set-upstream-to : 和-u同样的作用 查看设置的所有跟踪分支使用 git branch -vv 将所有的本地分支列出来并且包含更多的信息,如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有. 1234$ git branch -vv dev 3e910e9 add b.txt master 11b7fa8 [origin/master] test commit* test 9ef1783 [origin/test] Initial commit 拉取远程分支的修改使用 git pull &lt;remote&gt; &lt;branch&gt; 来拉取远程仓库中对应分支的修改到当前分支 1234567$ git pull origin masterFrom https://github.com/jianxin-yuan/git-flow-demo * branch master -&gt; FETCH_HEADUpdating 11b7fa8..d61e878Fast-forward a.txt | 1 + 1 file changed, 1 insertion(+) 如果当前分支已经有关系的跟踪分支,则可以简写为 git pull. git fetch 与 git pull 的区别git fetch 是将远程仓库中有而本地仓库中没有的数据拉取下来,它并不会修改工作目录中的内容. git pull 是将远程仓库数据拉取下来,并将变化合并到当前分支. 类似git fetch &amp;&amp; git merge的组合 删除远程分支使用 git push origin --delete &lt;remoteBranch&gt; 来删除远程分支 123$ git push origin --delete devTo https://github.com/jianxin-yuan/git-flow-demo.git - [deleted] dev]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git 分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git关联远程仓库]]></title>
    <url>%2Fblog%2Fposts%2F3490727497.html</url>
    <content type="text"><![CDATA[本文主要介绍Git远程仓库的使用 git远程仓库运行 git remote 命令, 它会列出你指定的每一个远程服务器的简写,如果是从远程克隆下来的项目,默认有一个origin 12$ git remoteorigin 可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL 123$ git remote -vorigin https://github.com/jianxin-yuan/git-flow-demo.git (fetch)origin https://github.com/jianxin-yuan/git-flow-demo.git (push) 运行git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写 1git remote add origin https://github.com/jianxin-yuan/git-flow-demo.git git fetch [remote-name] 会将数据拉取到你的本地仓库——但是它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 查看远程仓库信息12345678910111213$ git remote show origin* remote origin Fetch URL: https://github.com/jianxin-yuan/git-flow-demo.git Push URL: https://github.com/jianxin-yuan/git-flow-demo.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/dev stale (use 'git remote prune' to remove) test tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 清理无效的远程追踪分支清理origin对应的远程仓库的本地无效的追踪分支 git remote show origin 可以看到 refs/remotes/origin/dev stale (use &#39;git remote prune&#39; to remove)表示这个分支远程仓库已经删除了.. 1234$ git remote prune origin --dry-run ##查看可以被清除的跟踪分支Pruning originURL: https://github.com/jianxin-yuan/git-flow-demo.git * [would prune] origin/dev ##origin/dev 可以被清除 清除无效的追踪分支 1234$ git remote prune originPruning originURL: https://github.com/jianxin-yuan/git-flow-demo.git * [pruned] origin/dev ##origin/dev 被清除 重命名远程仓库命名 1$ git remote rename origin xxx 移除远程仓库 1$ git remote rm xxx 这些操作都是针对本地repository的,不会对远程仓库的东西造成影响.]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git 远程仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2Fblog%2Fposts%2F3490727498.html</url>
    <content type="text"><![CDATA[Git 入门版本控制工Git介绍和使用 Git文件区域和文件状态说明 Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 文件区域 Git 项目的三个工作区域：Git 仓库、工作目录以及暂存区域。 简单来说.工作目录就是当前进行操作的文件目录,当你运行git add后表示文件被加入了暂存区域,git commit后表示提交到了本地git repository 文件状态git文件分为已跟踪和未跟踪2类,已跟踪又分为未修改,已修改,已暂存 untracked(未跟踪): 未跟踪状态,表示未加入git版本控制中 unmodified(未修改): 表示和上一次提交相比没有修改过 modified(已修改): 表示和上一次提交相比有修改过 staged(已暂存): 表示修改已暂存(git add) , 下一次运行git commit 会将起提交到git仓库 git add命令理解:可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适 git status 状态查看运行git status可以查看当前git项目的文件状态 1234567891011121314151617$ git statusOn branch masterChanges to be committed: # 只要在 Changes to be committed 这行下面的，是已暂存文件 (use "git reset HEAD &lt;file&gt;..." to unstage) new file: b.txtChanges not staged for commit:# 只要在Changes not staged for commit 这行下面的，是已修改未暂存文件 (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: a.txtUntracked files: # 只要在 Untracked files 这行下面的，是未跟踪文件 (use "git add &lt;file&gt;..." to include in what will be committed) c.txt git status -s 简介模式查看 A表示已暂存文件 ??表示为跟踪文件 靠左M表示文件被修改并已放入暂存区 靠右M表示文件被修改但还没有放入暂存区 1234$ git status -s M a.txtA b.txt?? c.txt git diff 查看文件变化可查看已暂存的文件变化和已修改未暂存的文件变化 git diff 查看已修改未暂存的文件变化 123456789$ git diffdiff --git a/a.txt b/a.txtindex 72943a1..26a3e85 100644--- a/a.txt+++ b/a.txt@@ -1 +1,2 @@ aaa+xxx #表示新加的行(END) git diff –staged 查看已暂存文件的文件变化 git diff –staged 和 git diff –cache 是一样的 123456789$ git diff --stageddiff --git a/b.txt b/b.txtnew file mode 100644index 0000000..f761ec1--- /dev/null+++ b/b.txt@@ -0,0 +1 @@+bbb(END) git commit 提交暂存区文件到本地仓库使用git commit 可以将当前已暂存的文件提交到git的本地仓库中,未暂存的文件不会提交,需要用git add将已修改的文件提交到暂存区.也可以使用git commit -a 替代 git add + git commit, -m:加上提交的信息 -a:将已修改的文件加入暂存区 1234$ git commit -a -m "update"[master 97df9bf] update 2 files changed, 2 insertions(+) create mode 100644 b.txt git 撤销操作撤销已暂存文件有时,我们将某个文件提交到了暂存区.然后发现需要取消某个文件的暂存,这是可以使用git reset HEAD &lt;file&gt;来将已暂存的文件撤回到位暂存状态 123456789101112131415161718192021222324252627$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: a.txt modified: x.txt ########这里暂存区有2个文件已暂存,使用git reset HEAD取消暂存 $ git reset HEAD a.txt #取消暂存a.txtUnstaged changes after reset:M a.txt####再次查看状态$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: x.txtChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: a.txt ## a.txt已回到修改但未暂存状态 撤销文件内容修改如果我们需要将当前文件的修改撤销,还原成上次提交时的状态,可以使用git chekcout -- &lt;file&gt; 123456789101112131415$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: x.txt ###当前有一个已修改的文件 $ git checkout -- x.txt ##撤销对x.txt文件的修改 $ git statusOn branch masternothing to commit, working tree clean### 工作空间干净了...不过切记慎重操作,只有当你确定这次修改不要了,才这样做.因为这样操作本次的修改是找不回来的 git修改提交记录/提交信息有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交, 1$ git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git标签]]></title>
    <url>%2Fblog%2Fposts%2F3490727499.html</url>
    <content type="text"><![CDATA[Git标签Git 可以给历史中的某一个提交打上标签,以示重要,比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等,Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated) 轻量标签类似一个不会改变的分支,是一个特定提交的引用. 附注标签是存储在 Git 数据库中的一个完整对象. 它们是可以被校验的,其中包含打标签者的名字|电子邮件地址|日期时间.还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证. 通常建议创建附注标签 附注标签 创建使用git tag -a &lt;tagName&gt; -m &lt;tagMessage&gt; 来创建一个附注标签标签 1$ git tag -a v1.0 -m "version 1.0" 标签创建好后可以通过git show来查看标签的具体信息 1$ git show v1.0 轻量标签 创建使用git tag &lt;tagName&gt; 来创建一个附注标签标签 1$ git tag v1.1 历史提交标签 创建如果想给过去的某个版本创建一个tag也是可以的,只需要在命令后加上那次提交的校验码即可 1$ git tag -a Beta -m "Beta version" 9ef1783e4ecae0648db888aaa56e0ec9a9f3fb71 查看标签列表使用git tag可以查看标签列表 123456$ git tagBetav1.0v1.1(END) 推送标签到远程(单个)使用git push &lt;remote&gt; &lt;tagNmae&gt; 可以将本地标签推送到远程服务器 1234567$ git push origin v1.0Enumerating objects: 1, done.Counting objects: 100% (1/1), done.Writing objects: 100% (1/1), 159 bytes | 79.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0)To https://github.com/jianxin-yuan/git-flow-demo.git * [new tag] v1.0 -&gt; v1.0 推送标签到远程(多个)使用 git push &lt;remote&gt; --tags 可以将本地所有的标签推送到远程 12345678910$ git push origin --tagsEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 8 threadsCompressing objects: 100% (3/3), done.Writing objects: 100% (4/4), 424 bytes | 424.00 KiB/s, done.Total 4 (delta 0), reused 0 (delta 0)To https://github.com/jianxin-yuan/git-flow-demo.git * [new tag] Beta -&gt; Beta * [new tag] v1.1 -&gt; v1.1 删除本地标签使用git tag -d &lt;tagName&gt; 可以删除本地标签 12$ git tag -d BetaDeleted tag 'Beta' (was ffc10b2) 删除远程标签使用 git push &lt;remote&gt; :refs/tags/&lt;tagNmae&gt; 可以删除远程分支,其实删除远程标签和推送远程标签是一样的.只是推送一个空的源标签到远程 123$ git push origin :refs/tags/BetaTo https://github.com/jianxin-yuan/git-flow-demo.git - [deleted] Beta 检出标签检出标签和检出一个分支是一样的.使用git checkout -b &lt;branchName&gt; &lt;tagName&gt; 来将标签检出到一个新的分支,用与后续使用 12$ git checkout -b v1.0_test v1.0Switched to a new branch 'v1.0_test']]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myabtis-generator使用]]></title>
    <url>%2Fblog%2Fposts%2F2264618867.html</url>
    <content type="text"><![CDATA[利用mybatis generator 生成model/mapper/xml,同时添加数据库注释 方式1,测试类运行1.新建一个简单maven项目(也可直接使用已有项目) 2.添加依赖.修改pom.xml 123456789101112131415&lt;dependencies&gt; &lt;!--mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.在resources下新建配置文件generator.properties,配置数据库信息 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.connectionURL=jdbc:mysql://127.0.0.1:3306/yuan?useUnicode=true&amp;characterEncoding=utf-8jdbc.userId=rootjdbc.password=root 新建自定义注释处理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.yuan.mgb;import org.mybatis.generator.api.IntrospectedColumn;import org.mybatis.generator.api.IntrospectedTable;import org.mybatis.generator.api.dom.java.Field;import org.mybatis.generator.api.dom.java.TopLevelClass;import org.mybatis.generator.internal.DefaultCommentGenerator;import java.time.LocalDate;import java.util.Properties;/** * 可以直接实现CommentGenerator,不过方法太多,没必要.只需要继承DefaultCommentGenerator,重写需要用到的方法即可 * @author yuan * @date 2019/10/11 10:50 上午 */public class CustomCommentGenerator extends DefaultCommentGenerator &#123; @Override public void addConfigurationProperties(Properties properties) &#123; super.addConfigurationProperties(properties); &#125; /** * 实体注释 * * @param topLevelClass * @param introspectedTable */ @Override public void addModelClassComment(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123; String remarks = introspectedTable.getRemarks(); topLevelClass.addJavaDocLine("/**"); if (null != remarks &amp;&amp; !"".equals(remarks)) &#123; topLevelClass.addJavaDocLine(" * " + remarks); topLevelClass.addJavaDocLine(" *"); &#125; topLevelClass.addJavaDocLine(" * @author " + System.getProperty("user.name")); topLevelClass.addJavaDocLine(" * @date " + LocalDate.now()); topLevelClass.addJavaDocLine(" */"); &#125; /** * 字段注释 * * @param field * @param introspectedTable * @param introspectedColumn */ @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) &#123; String remarks = introspectedColumn.getRemarks(); field.addJavaDocLine("/**"); if (null != remarks &amp;&amp; !"".equals(remarks)) &#123; field.addJavaDocLine(" * " + remarks); &#125;else&#123; field.addJavaDocLine(" * " + "TODO"); &#125; field.addJavaDocLine(" */"); &#125;&#125; 新建generatorConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--配置文件--&gt; &lt;properties resource="generator.properties"/&gt; &lt;!-- 配置环境 defaultModelType:指定生成模型类型策略 1.conditional:这是默认值,这个模型和下面的hierarchical类似，除了如果那个单独的类将只包含一个字段，将不会生成一个单独的类。 因此,如果一个 表的主键只有一个字段,那么不会为该字段生成单独的实体类,会将该字段合并到基本实体类中。 2.flat:该模型为每一张表只生成一个实体类。这个实体类包含表中的所有字段。 3.hierarchical:如果表有主键,那么该模型会产生一个单独的主键实体类,如果表还有BLOB字段， 则会为表生成一个包含所有BLOB字段的单独的实体类,然 后为所有其他的字段生成一个单独的实体类。 MBG会在所有生成的实体类之间维护一个继承关系。 --&gt; &lt;context id="MySqlContext" targetRuntime="MyBatis3" defaultModelType="flat"&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;!--可以自定义生成model的代码注释--&gt; &lt;commentGenerator type="com.yuan.mgb.CustomCommentGenerator"&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="addRemarkComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库连接--&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driverClass&#125;" connectionURL="$&#123;jdbc.connectionURL&#125;" userId="$&#123;jdbc.userId&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt; &lt;property name="nullCatalogMeansCurrent" value="true"/&gt; &lt;/jdbcConnection&gt; &lt;!--指定生成model的路径 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage="com.yuan.model" targetProject="src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!--指定生成mapper.xml的路径--&gt; &lt;sqlMapGenerator targetPackage="com.yuan.mapper" targetProject="src/main/java"/&gt; &lt;!--指定生成mapper接口的的路径 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.yuan.mapper" targetProject="src/main/java"/&gt; &lt;table schema="yuan" tableName="user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 新建测试类 1234567891011121314151617181920public class App &#123; public static void main(String[] args) &#123; try &#123; List&lt;String&gt; warnings = new ArrayList&lt;&gt;(); InputStream inputStream = ClassLoader.getSystemResourceAsStream("generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(inputStream); DefaultShellCallback callback = new DefaultShellCallback(true); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(new VerboseProgressCallback()); for (String warning : warnings) &#123; System.out.println(warning); &#125; &#125; catch (IOException | SQLException | InterruptedException | InvalidConfigurationException | XMLParserException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 方式2.maven plugin使用maven插件,在pom.xml中加入配置 12345678910111213141516171819202122232425262728293031323334353637&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- mybatis-generator-maven-plugin --&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!--覆盖已有文件--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;!--运行时依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--本地依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.yuan&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/target/mybatis-generator-1.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如果需要使用自定义注释处理类.需要将我们的处理类先打包.然后使用本地依赖的方法导 在项目下运行 mav install,可以看到target下有对应的jar文件.在plugin中引入本地依赖即可(记得修改你项目的groupId,artifactId等参数) ​ ​ com.yuan​ mybatis-generator​ 1.0​ system​ ${basedir}/target/mybatis-generator-1.0.jar​ 运行mvn mybatis-generator:generate 即可,如果使用idea,也可以直接点击图中命令运行]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm+shiro实现登录认证授权]]></title>
    <url>%2Fblog%2Fposts%2F1988423942.html</url>
    <content type="text"><![CDATA[Apache Shiro 是Java 的一个安全框架.Shiro 可以非常容易的开发出足够好的应用,其不仅可以用在JavaSE 环境,也可以用在JavaEE 环境.Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与Web 集成、缓存等. 本文示例源码:https://github.com/jianxin-yuan/shiro/tree/master/shiro-ssm ssm集成shiro引入依赖shiro-spring12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; 新增UsrRealm类,实现认证和授权方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.yuan.realm;import com.yuan.dto.ActiveUser;import com.yuan.model.Permission;import com.yuan.model.Role;import com.yuan.model.User;import com.yuan.service.PermissionService;import com.yuan.service.RoleService;import com.yuan.service.UserService;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import org.springframework.beans.factory.annotation.Autowired;import java.util.List;import java.util.stream.Collectors;/** * @author yuan * @date 2019/10/13 6:41 下午 */public class UserRealm extends AuthorizingRealm &#123; @Autowired private UserService userService; @Autowired private RoleService roleService; @Autowired private PermissionService permissionService; /** * 授权方法 * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //拿到认证成功设置的principal信息 ActiveUser activeUser = (ActiveUser) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //用户角色 List&lt;String&gt; roles = activeUser.getRoles(); if (roles != null &amp;&amp; roles.size() &gt; 0) &#123; info.addRoles(roles); &#125; //用户权限 List&lt;String&gt; permissions = activeUser.getPermissions(); if (permissions != null &amp;&amp; permissions.size() &gt; 0) &#123; info.addStringPermissions(permissions); &#125; return info; &#125; /** * 认证方法 * * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; UsernamePasswordToken ut = (UsernamePasswordToken) token; //根据用户名查询用户 User user = userService.getUserByName(ut.getUsername()); if (user != null) &#123; //根据用户ID查询角色列表 List&lt;Role&gt; roleList = roleService.findByUserId(user.getId()); List&lt;String&gt; roles = roleList != null ? roleList.stream().map(Role::getName).collect(Collectors.toList()) : null; //根据用户ID查询权限列表 List&lt;Permission&gt; permissionList = permissionService.findByUserId(user.getId()); List&lt;String&gt; permissions = permissionList != null ? permissionList.stream().map(Permission::getCode).collect(Collectors.toList()) : null; //构建一个包含了用户信息 &amp; 角色信息 &amp; 权限信息 的实体 ActiveUser activeUser = new ActiveUser(user, roles, permissions); //加密盐值 ByteSource salt = ByteSource.Util.bytes(user.getSalt()); /** * 参数说明 * 参数1:活动的用户.用于后续授权 * 参数2:加密的密码 * 参数3:加密的盐值 * 参数4:当前realm类名.不重要 */ return new SimpleAuthenticationInfo(activeUser, user.getPassword(), salt, this.getName()); &#125; return null; &#125;&#125; 修改spring配置文件 新增applicationContext-shiro.xml配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--凭证匹配器--&gt; &lt;bean id="credentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;!--加密算法--&gt; &lt;property name="hashAlgorithmName" value="md5"/&gt; &lt;!--散列次数--&gt; &lt;property name="hashIterations" value="2"/&gt; &lt;/bean&gt; &lt;!--userRealm--&gt; &lt;bean id="userRealm" class="com.yuan.realm.UserRealm"&gt; &lt;property name="credentialsMatcher" ref="credentialsMatcher"/&gt; &lt;/bean&gt; &lt;!--securityManager 使用shiro-spring集成的类--&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="userRealm"/&gt; &lt;/bean&gt; &lt;!-- 配置shiro中bean生命周期管理器 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- AOP式方法级权限检查 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;!--shiro filter--&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!--登录页面--&gt; &lt;property name="loginUrl" value="/toLogin"/&gt; &lt;!--未授权页面--&gt; &lt;property name="unauthorizedUrl" value="/unauthorized"/&gt; &lt;!--登录成功跳转的页面--&gt; &lt;property name="successUrl" value="/main"/&gt; &lt;!-- 配置过滤器链 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!-- 放行index.jsp --&gt; /index.jsp*=anon &lt;!-- 放行跳转到登陆页面的路径 --&gt; /toLogin*=anon &lt;!-- 放行登陆的请求 --&gt; /login*=anon &lt;!--放行注册--&gt; /user/register*=anon &lt;!-- 设置登出的路径 --&gt; /logout*=logout &lt;!-- 设置其它路径全部拦截 --&gt; /**=authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在applicationContext.xml中引入shiro配置文件 1&lt;import resource="classpath*:spring/applicationContext-shiro.xml"/&gt; 在spring-mvc.xml中加入配置 12&lt;!-- 开启shiro中aop注解 --&gt;&lt;aop:config proxy-target-class="true"/&gt; 修改web.xml,新增shrioFilter配置 1234567891011121314151617&lt;filter&gt; &lt;!--filter-name需要与applicationContext-shiro.xml中配置的filter的ID一致--&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetBeanName&lt;/param-name&gt; &lt;param-value&gt;shiroFilter&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;/filter-mapping&gt; 新建LoginController用于登录 登录方法,调用Subject的login即可 1234567891011121314151617@RequestMapping("/login") public String login(String userName, String password, HttpSession session, Model model) &#123; Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(new UsernamePasswordToken(userName, password)); ActiveUser user = (ActiveUser) subject.getPrincipal(); session.setAttribute("user", user); log.info("登陆成功"); model.addAttribute("userName", user.getUser().getUsername()); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); log.warn("登陆失败"); return "redirect:toLogin"; &#125; return "success"; &#125; 至此.shiro的集成基本完成.之后的权限控制,如果是在前端jsp页面控制权限,使用shiro标签即可 12&lt;shiro:hasPermission name="user:add"&gt;&lt;/shiro:hasPermission&gt;&lt;shiro:hasRole name=""&gt;&lt;/shiro:hasRole&gt; 如果是前后端分离的项目.在需要权限控制的方法上加上shiro注解即可 12@RequiresPermissions()@RequiresRoles() Q &amp; Aspringmvc中Shiro注解无效问题的解决方案?shiro注解配置有2种方法. 方法1 在applicationContext-shiro.xml中加入开启shiro注解的配置 1234567&lt;!-- 配置shiro中bean生命周期管理器 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- AOP式方法级权限检查 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; 在spring-mvc.xml中加入配置 12&lt;!-- 开启shiro中aop注解 --&gt;&lt;aop:config proxy-target-class="true"/&gt; 方法2 直接将开启注解的配置加入spring-mvc.xml中.这样就不用加&lt;aop:config proxy-target-class=&quot;true&quot;/&gt;]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven编译打包的JDK版本]]></title>
    <url>%2Fblog%2Fposts%2F512639517.html</url>
    <content type="text"><![CDATA[idea新建maven项目时.默认使用的是JDK1.5,导致经常我们设置了jdk版本也提示不对.这里介绍一下正确的设置方法. 全局设置 全局配置是指在${MAVEN_HOME}\conf\settings.xml中进行配置，这样以后新建的项目默认就会使用这里配置的JDK版本,在 &lt;profiles&gt;节点下加入下面的配置 12345678910111213&lt;profile&gt; &lt;id&gt;jdk11&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;11&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!--使用JDK11编译--&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;11&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; ${MAVEN_HOME}指的是maven的安装目录 项目设置 可以对每个项目单独设置编译的JDK版本,这里也分插件方式和属性方式 插件方式 在项目的pom.xml中加入下面配置即可 1234567891011121314&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- maven-compiler-plugin:设置项目jdk开发和编译版本 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 属性方式 在项目pom.xml中加入下列配置,同时可以指定文件编码 12345678&lt;properties&gt; &lt;!--JDK版本--&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;!--文件编码--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt;]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>JDK版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-asset-image与hexo-abbrlink带给我的苦恼]]></title>
    <url>%2Fblog%2Fposts%2F2897252909.html</url>
    <content type="text"><![CDATA[hexo-abbrlink是设置永久链接的插件,hexo-asset-image是设置图片地址的插件,分开了用皆大欢喜,但当我们都用上后发现会出现各种问题.愁死个人呐! 😂😂😂 本文记录了几个个人遇到的问题及最终的解决方法 hexo-asset-image介绍首先当我们启用了hexo-asset-image后,会设置next/_config.yml的post_asset_folder节点为ture 1post_asset_folder: true 这个时候当我们运行 hexo new “test”,生成一篇文章后,在同级目录下会生成一个同名的(test)文件夹,我们文章里的图片都需要放入这个文件夹里,结构如下 123├── test│ └── banner.jpg└── test.md 这样在markdown里引用文件就可以写成这样 1![banner图片](test/banner.jpg) 然后hexo g 生成的页面中就可以看到图片了. 如何你的图片都正常显示,那恭喜你.接下来的文章你可以不看了…………….. 问题1 permalink=:abbrlink.html 显示异常 将permalink=:abbrlink.html 设置为.html后缀时,可以将网站模拟成伪静态.这对SEO是有好处的,但是这会导致heox-asset-image替换图片地址是出现bug,百度,google了半天没找到解决办法(ps:倒是看了一堆废话),最后想到了直接上GitHub hexo-asset-image 上去看看项目的issue,结果还真有.嘿嘿嘿😝. 有好几个issue都有提到这个问题,比如issue-21,issue-19,但是作者自己也没有解决,最后在issue-48里找到了答案.然后自己修改了下hexo-asset-image 插件的 index.js(位置在站点根目录/node_modules/hexo-asset-image/index.js),最终解决!!!,加入下面代码到指定位置即可 123else if(/.*\.html$/.test(link))&#123; var endPos = link.length-5; &#125; 这样当你的permalink设置为下面几种格式,图片都是可以正常显示的 1234permalink: :abbrlink.html --&gt; http://localhost:4000/blog/3632233996.htmlpermalink: :abbrlink/ --&gt; http://localhost:4000/blog/3632233996/permalink: :year/:month/:day/:title/ --&gt; http://localhost:4000/blog/2019/10/11/test/permalink: :year/:month/:day/:title/index.html --&gt; http://localhost:4000/blog/2019/10/11/test/index.html 问题2 站点运行在子目录下时 显示异常 由于我的博客是运行在子目录的.next/_config.yml配置如下. 12url: https://jianxin-yuan.github.io/blog/root: /blog/ 所有在hexo-asset-image替换图片的时候会将/blog/重复2次,导致图片无法正常显示,如下 这个问题同样是在 issue-52 上找到的答案 修改index.js 12345var directory_Depth = 3;var child_Depth = config.root.split("/").length - 2;directory_Depth = child_Depth &gt; 0 ? directory_Depth + child_Depth : directory_Depth; var beginPos = getPosition(link, '/', directory_Depth) + 1; 后续版本不知道作者会不会修复这些问题.提了个PR,也不知道会不会采纳…愁啊….. 总结百度不出来? google还不行? 那就上项目的GitHub上去找答案吧.项目的issue里藏了无数的宝藏]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>hexo-asset-image</tag>
        <tag>hexo-abbrlink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot-devtools 热部署]]></title>
    <url>%2Fblog%2Fposts%2F1584421437.html</url>
    <content type="text"><![CDATA[开发过程中,热部署是一个十分重要的功能,避免了频繁重启应用带来的时间上的浪费,Spring Boot作为当前最火的java企业级应用开发框架.自然也是提供了相应功能.spring-boot-devtools是Spring Boot提供的一个开发工具模块,提供了一系列好用的功能,使应用程序开发更加快速和高效. 依赖 Maven 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle 123456789configurations &#123; developmentOnly runtimeClasspath &#123; extendsFrom developmentOnly &#125;&#125;dependencies &#123; developmentOnly("org.springframework.boot:spring-boot-devtools")&#125; 加入spring-boot-devtools后,当类路径下的文件发生变化时,应用程序就会重新启动.不过这个启动比正常手动重启会快很多. 这源于spring boot 重启技术使用2个类加载器,不会更改的类(如第三方jar包等)加载到一个base classloader中,我们正在开发的类将加载到restart classloader中.重启应用程序时,只会重启restart classloader,这样避免了大量第三方类的加载,节省了大量时间. IDEA中配置 由于spring-boot-devtools只有在检测到类路径下的文件变化时才会触发重启,而IDEA是默认是不会自动编译文件的.所以会出现修改了类文件,html.js等.但没有重启的情况.这里介绍2种解决方法 方式1:修改springboot configuration实现(个人推荐) 点击Run &gt; Edit Configurations 进入配置页面 将 on frame deactivation 修改为 update classes and resoruce,这个表示idea失去焦点时(如切换到浏览器或其他界面)更新class 和resource,然后就会触发spring-boot-devtools的重启机制了. 方式2:修改idea为自动编译进入 Preferences &gt; compiler,勾选build project automatically 双击shift,输入registry 勾选compiler.automake.allow.when.app.running 即可开启idea的自动编译,重启项目,修改文件.可以看到spring boot会重启了 使用触发文件 有时我们不希望每次更改都重启应用.这时可以使用触发文件来实现.当我们希望应用重启的时候,只需要修改这个特殊的文件spring-boot-devtools检测到这个文件改变了.就会触发重启. 1spring.devtools.restart.trigger-file= #触发文件路径 自定义重启类加载器 当我们开发一个多模块的项目时,可能我们只是修改很小的一部分代码,但是spring-boot-devtools还是会将整个项目代码重新加载,这会拖慢启动速度.这时我们可以自定义重启类加载器,指定哪些文件需要重启时加载. 创建一个META-INF/spring-devtools.properties文件 12restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jarrestart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar spring-devtools.properties文件可以包含前缀为restart.exclude和restart.include的属性。include元素表示重启时需要重新加载的项目，exclude元素表示下沉到 base classesloader的项目,只在第一次启动时加载,后续重启不重新加载.该属性的值是应用于类路径的正则表达式模式,所有属性键必须是唯一的,只要属性以restart.include.或restart.exclude.开头,就会被考虑.]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>热部署</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT进阶配置]]></title>
    <url>%2Fblog%2Fposts%2F3790268221.html</url>
    <content type="text"><![CDATA[前言本文主要介绍Next的一些进阶配置,如集成评论系统,本地搜索,进度条等.各种第三方服务集成,个人定制化.能让你的博客具备完善的功能…. 进阶配置设置永久链接 设置永久链接有利于SEO,即使后续文章title变化,也不会博客访问路径造成影响,在站点根目录运行下面命令安装依赖 1npm install hexo-abbrlink --save 修改hexo/_config.yml下的permalink配置,并新增abbrlink节点内容 1234567permalink: posts/:abbrlink/# abbrlink config## https://github.com/rozbo/hexo-abbrlinkabbrlink: alg: crc32 # support crc16(default) and crc32 rep: dec # support dec(default) and hex alg和rep可选择不同组合方案,下面是各种组合的效果,可以自行选择喜欢的组合 本地搜索 本地搜索不需要第三方服务,只需要添加依赖就可以了,在站点根目录运行下面命令安装依赖 1npm install hexo-generator-searchdb --save 在hexo/_config.yml下添加下列配置 123456# local searchsearch: path: search.xml field: post format: html limit: 10000 修改next/_config.yml下面的local_search节点内容 1234567891011121314# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true #开启服务 # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto #自动触发搜索 #trigger: manual #手动触发 # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 此时菜单栏就会出下搜索🔍了, 如果你前面在menu配置项里有配置搜索的话,这里会出现2个搜索,把菜单里的搜索注释掉就行了 顶部阅读进度条 进入themes/next目录,运行下面的命令 1git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress 修改next/_config.yml下的reading_progress节点,注意不是vendors下的reading_progress 123456# Reading progress bar# Dependencies: https://github.com/theme-next/theme-next-reading-progressreading_progress: enable: true #启用 color: "#37c6c0" #颜色 height: 2px #高度 文章加载进度条 进入themes/next目录,运行下面的命令 1git clone https://github.com/theme-next/theme-next-pace source/lib/pace 修改next/_config.yml下的pace节点,注意不是vendors下的pace 123456pace: enable: true #启用 # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: flash #加载样式 文章字数统计和阅读时间 进入站点根目录,运行命令安装插件 1npm install hexo-symbols-count-time --save 修改hexo/_config.yml,添加下列内容 12345678# Hexo plugin: hexo-symbols-count-time# https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: symbols: true # 文章字数统计 time: true # 文章预计阅读时间 total_symbols: true # 页面底部站点总字数统计 total_time: true # 页面底部站点总阅读时间预计 exclude_codeblock: false #是否排除代码块内容 修改next/_config.yml下的symbols_count_time节点 12345678# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true #是否换行显示 item_text_post: true #是否显示文章统计的文本说明 item_text_total: true #是否显示站点统计的文本说明 awl: 2 #平均字长 wpm: 300 #阅读速度 分享按钮 进入themes/next目录,运行下列命令 1git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 修改next/_config.yml下的NeedMoreShare2节点 12345678910111213141516171819202122232425# NeedMoreShare2# Dependencies: https://github.com/theme-next/theme-next-needmoreshare2# For more information: https://github.com/revir/need-more-share2# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks:# Weibo | Wechat | Douban | QQZone | Twitter | Facebook | Linkedin | Mailto | Reddit | Delicious | StumbleUpon | Pinterest# GooglePlus | Tumblr | GoogleBookmarks | Newsvine | Evernote | Friendfeed | Vkontakte | Odnoklassniki | Mailruneedmoreshare2: enable: true #启用分享功能 postbottom: enable: true #启用文章结尾分享按钮 options: iconStyle: default boxForm: horizontal #horizontal表示分享列表水平排列,vertical表示竖直排列 position: topCenter #表示在按钮上部中间出现分享列表top / middle / bottom + Left / Center / Right 可自由组合,如topLeft,表示上部左边,bottomCenter表示下部中间 networks: Weibo,Wechat,Douban,QQZone #分享的平台 float: enable: false #启用侧边栏分享按钮 options: iconStyle: default boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 个性化回到顶部 就是右侧那个猫咪啦→→→,首先找一张喜欢的图片,将图片放入/hexo/source/images/目录下, 点击下载 修改next/_config.yml下的custom_file_path节点 1234567891011custom_file_path: #head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig #postMeta: source/_data/post-meta.swig #postBodyEnd: source/_data/post-body-end.swig #footer: source/_data/footer.swig #bodyEnd: source/_data/body-end.swig #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl style: source/_custom/custom.styl # 根目录下的/source/,不是主题下的/source/ 在hexo/source/目录下新建_custom目录,添加custom.styl文件,加入下面的内容 123456789101112131415161718//自定义回到顶部样式.back-to-top &#123; right: 25px; width: 70px; //图片素材宽度 height: 900px; //图片素材高度 top: -900px; //bottom: unset; transition: all .5s ease-in-out; background url("../images/scroll.png") //隐藏箭头图标 &gt; i &#123; display: none; &#125; &amp;.back-to-top-on &#123; bottom: unset; top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px; &#125;&#125; 注意:这里需要将next/_config.yml下的侧边栏回到顶部back2top.sidebar关掉,不然会有点小问题 1234567&gt; back2top:&gt; enable: true&gt; # Back to top in sidebar.&gt; sidebar: false&gt; # Scroll percent label in b2t button.&gt; scrollpercent: true&gt; 图片放大预览 图片预览可以使用fancybox或者mediumzoom,但是不要同时启用2个,不然会出现2次预览 fancybox安装. 进入themes/next目录,运行命令 1git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox 修改next/_config.yml下的fancybox节点 123456# Fancybox. There is support for old version 2 and new version 3.# Choose only one variant, do not need to install both.# To install 2.x: https://github.com/theme-next/theme-next-fancybox# To install 3.x: https://github.com/theme-next/theme-next-fancybox3# For more information: https://fancyapps.com/fancyboxfancybox: true mediumzoom安装 进入themes/next目录,运行命令 1git clone https://github.com/theme-next/theme-next-mediumzoom source/lib/mediumzoom 修改next/_config.yml下的mediumzoom节点 12345# A JavaScript library for zooming images like Medium.# Do not enable both `fancybox` and `mediumzoom`.# Dependencies: https://github.com/theme-next/theme-next-mediumzoom# For more information: https://github.com/francoischalifour/medium-zoommediumzoom: true 集成Gitalk评论系统 新版的NexT已经集成了几种主流的评论系统.disqus/disqusjs/changyan/valine/gitalk,这里选择的是gitalk,主要是gitalk是基于github的Issue,同时需要登录GitHub账号才能评论.毕竟,如果你要喷我.那也要留下你的大名呀.匿名的键盘侠还是不要评论我的博客了…..🤣🤣🤣,好了,开干… 首先注册一个 OAuth application Application name: 应用名称,随便取 Homepage URL : 你的博客站点Url Application description : 介绍,随便写 Authrization callback URL : 你的博客站点Url 下面是注册成功页面,主要就是Client ID和 Client Secret,如果不小心关闭了页面找不到了.可以从settings &gt; Developer settings &gt; OAuth Apps 找到 修改next/_config.yml下的Gitalk节点 注意:下面配置的repo表示GitHub上一个仓库的名称,因为gitalk是基于GitHub的issue系统的,相当于每次评论是在对应repo的issue上进行留言,这里推荐新建一个repo来专门存放评论,同时repo配置的值是你仓库的名字,而不是git的地址.如果你的仓库是https://github.com/youname/xxx,那repo的值就是xxx 123456789101112131415# Gitalk# Demo: https://gitalk.github.io# For more information: https://github.com/gitalk/gitalk, https://github.com/emn178/js-md5gitalk: enable: true #开启 github_id: # GitHub 账号名称 repo: # Repository name to store issues client_id: # 上一步生成的 GitHub Application Client ID client_secret: # 上一步生成的 GitHub Application Client Secret admin_user: # GitHub 账号名称 distraction_free_mode: true # Facebook-like distraction free mode # Gitalk's display language depends on user's browser or system environment # If you want everyone visiting your site to see a uniform language, you can set a force language value # Available values: en | es-ES | fr | ru | zh-CN | zh-TW language: 发布到远程站点,随便进入一篇文章就可以看到评论系统了.第一次需要登录你的GitHub账号,每篇博文都需要所有者进入后进行初始化,不然别人是不能评论的,每篇博文的评论在你的repo中就是一个issue,如果想要清空某个文章的评论,只需要找到对应的的issue关闭掉issue就行了,下次进入这个文章的时候会重新初始化评论… 参考链接 yearito|Hexo 搭建个人博客系列：主题美化篇 wylu|NexT主题进阶配置 NexT Theme Doc]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT主题配置]]></title>
    <url>%2Fblog%2Fposts%2F3790268220.html</url>
    <content type="text"><![CDATA[说一说Hexo是一个十分优秀的博客系统,上手也是十分的容易,当我们将博客搭建好了后,当然是想要一个能满足个人审美的主题,让我们的博客看起来狂拽炫酷高大上…..Hexo有许多许多的主题样式(https://hexo.io/themes/), 可以根据自己的需要选择,下面介绍的是一款十分优秀且受欢迎的主题NexT. NexT GitHub地址 NexT 官方文档 环境说明 Hexo和NexT都是使用的最新的版本,可能一些配置和低版本不一样,若存在不一致的地方.请查看官网文档来查找低版本支持方案… 123hexo: 3.9.0hexo-cli: 2.0.0next: 7.3.0 NexT主题安装使用Hexo有两个主要的配置文件,它们都被称为_config.yml 第一个是在站点根目录下(./_config.xml),其中包含Hexo的配置. 第二个是在主题根目录下(./themes/next/_config.yml),由NexT提供并包含主题的配置. 为了方便区分,我们称第一个 为 站点配置文件(hexo/_config.yml)，第二个 主题配置文件(next/_config.xml) 后续文中出现的路径在站点目录下的用hexo/前缀表示,在主题文件目录下的用next/前缀表示 下载NexT,进入你的hexo博客根目录,运行命令 1git clone https://github.com/theme-next/hexo-theme-next themes/next 修改 hexo/_config.yml 1theme: next 然后重新启动下hexo服务,看看效果吧! NexT个性配置Hexo和NexT都有许多的配置项,这里将一些比较常用的,有更多需求的小伙伴可以多多研究下官方文档,发掘更多好玩的有意思的特性… 主题 NexT有4个风格的主题,通过修改next/_config.yml 下的Scheme即可 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse# scheme: Mistscheme: Pisces# scheme: Gemini 站点基本信息 站点名称,介绍,语言等基本信息的配置,修改hexo/_config.yml 12345678# Sitetitle: # 网站名称subtitle: #子名称description: #一句简单介绍keywords: #用于SEOauthor: #作者名language: zh-CN #语言,默认是英语,可修改为中文timezone: 头像 修改next/_config.yml下的avatar节点 url表示头像路径,可以在hexo/source目录下建一个uplaods目录存放,也可以直接放到next/source/images/里面,也可以使用一个远程图片地址 rounded表示头像切割为圆形框 rotated表示鼠标点击时头像旋转 12345678910# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # If true, the avatar would be rotated with the cursor. rotated: false 菜单栏 修改next/_config.yml下的menu节点,默认配置是只有home和archives的,开启其他的菜单需要建立对应的目录文件,根据需要配置需要的菜单即可. 例:如果需要标签菜单,首先把配置文件下的tags前的#去掉,然后在hexo根目录下运行命令 hexo new page tags ,此时会在hexo/source/目录下会生成/tags/目录,/tags/里有一个index.md文件,打开文件,新增文件type字段配置,,title可随意更改,页面展示使用,其他菜单的操作也是同样的 123456&gt; ---&gt; title: 标签&gt; date: 2019-08-03 20:55:14&gt; type: tags&gt; ---&gt; 12345678910111213141516171819202122232425 # --------------------------------------------------------------- # Menu Settings # --------------------------------------------------------------- # Usage: `Key: /link/ || icon` # Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive. # Value before `||` delimiter is the target link. # Value after `||` delimiter is the name of Font Awesome icon. If icon (with or without delimiter) is not specified, question icon will be loaded.# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives). # External url should start with http:// or https:// menu: home: / || home #主页 #about: /about/ || user #关于我 tags: /tags/ || tags #标签 categories: /categories/ || th #分类 archives: /archives/ || archive #归档 # search: /search/ || search #搜索 #schedule: /schedule/ || calendar 日程表 #sitemap: /sitemap.xml || sitemap 站点地图 #commonweal: /404/ || heartbeat 公益404 # Enable / Disable menu icons / item badges. menu_settings: icons: true #是否显示图标 badges: true #是否显示徽章 404页面 想要定制一个404页面也是十分简单,和生成标签页类似,运行hexo new page 404,会在hexo/source/目录下生成/404/index.md文件.设置文件permalink: /404,并加上这段js(腾讯提供的公益404页面,当然也可以自己定制一些喜欢的404页面),这样当访问不存在的页面时就会显示404自定义的404页面了(本地测试不生效,需要部署到远程看效果) 12345678---title: 404date: 1970-01-01 00:00:00permalink: /404---&lt;script src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="Back to home"&gt;&lt;/script&gt; Favicon 在hexo/source/目录下新建/images/目录,将你的Favicon放入,然后修改next/_config.yml下的favicon节点 关于Favicon的生成,有很多网站都可以在线生成,需要的小伙伴自行百度吧 123456789101112# ---------------------------------------------------------------# Site Information Settings# See: https://theme-next.org/docs/getting-started/# ---------------------------------------------------------------favicon: small: /images/favicon-16x16.png medium: /images/favicon-32x32.png apple_touch_icon: /images/apple-touch-icon.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 代码块 修改next/_config.yml下的codeblock节点内容,支持normal | night | night eighties | night blue | night bright五种代码样式 123456789101112codeblock: # Code Highlight theme # Available values: normal | night | night eighties | night blue | night bright # See: https://github.com/chriskempson/tomorrow-theme highlight_theme: normal #代码样式主题 # Add copy button on codeblock copy_button: enable: true #表示启用复制按钮 # Show text copy result. show_result: true #表示显示复制结果 # Available values: default | flat | mac style: default #表示代码块风格, default | flat | mac 3个选项 侧边栏 侧边栏有几个选项，position，width，display，offset，onmobile和dimmer,通过修改next/_config.yml文件的sidebar节点 12345678910111213141516171819202122sidebar: # Sidebar Position. position: left #侧边栏位于左侧 #position: right #右侧 # Manual define the sidebar width. If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 #width: 300 #宽度 #侧边栏显示条件 # Sidebar Display (only for Muse | Mist), available values: # - post expand on posts automatically. Default.仅在具有索引的帖子中显示侧栏 # - always expand for all pages automatically.在所有页面中显示侧栏 # - hide expand only when click on the sidebar toggle icon.在所有页面中隐藏它（但可以由用户手动打开） # - remove totally remove sidebar including sidebar toggle.完全删除侧栏 display: always # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 #偏移量 # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false 侧边栏社交链接 编辑next/_config.yml下的social节点,放上你的GitHub,email,各种社交地址都行 123456social: # 格式:显示名称: url地址 || 图标 GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter GitHub Banner 修改next/_config.yml下的github_banner节点内容 1234github_banner: enable: true #默认为false,改为true permalink: https://github.com/jianxin-yuan #你的GitHub地址 title: Follow me on GitHub #鼠标悬停时的提示文字 首页摘要显示 默认情况下首页会显示整个文章内容.这是十分不合适的.一般我们想要的是首页展示一个摘要信息,点击文章查看全部内容.设置的方法有3种 推荐: 使用&lt;!-- more --&gt;标签,在需要展示的摘要内容后加上这个标签,那么标签之前的内容会展示到首页. 用法: 设置固定内容,修改next/_config.yml下的auto_excerpt节点,会展示文章前N字的内容 123auto_excerpt: enable: true #开启length: 300 #字数 修改next/_config.yml中的excerpt_description节点为true,并在文章的Front-matter中设置description,那里首页就会展示description的内容(不推荐.) 1excerpt_description: true 网站页脚设置 修改next/_config.yml下的footer内容 12345678910111213141516171819202122232425262728footer: # Specify the date when the site was setup. If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart #图标 # If you want to animate the icon, set it to true. animated: true #启用动画效果 # Change the color of icon, using Hex Code. color: "#ff0000" #图标颜色 # If not defined, `author` from Hexo `_config.yml` will be used. copyright: powered: # Hexo link (Powered by Hexo). enable: true #显示hexo信息 # Version info of Hexo after Hexo link (vX.X.X). version: true #显示hexo版本 theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true #显示主题信息 # Version info of NexT after scheme info (vX.X.X). version: true #显示主题版本 # Beian ICP information for Chinese users. See: http://www.beian.miit.gov.cn beian: enable: false icp: 字体 修改next/_config.yml下的font节点内容,NexT设置了5个类别的字体设置,可根据需要修改,内置的都是Google Fonts的字体,当然也可以引入其他字体库,这里我就偷懒不做了….默认字体挺好的😜😜😜 global：整个站点中使用的字体 title ：网站标题使用的字体 headings：文章中标题使用的字体（h1，h2，h3，h4，h5，h6 posts：文章使用的字体 codes：文章中代码块使用的字体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# ---------------------------------------------------------------# Font Settings# See: https://theme-next.org/docs/theme-settings/#Fonts-Customization# ---------------------------------------------------------------# Find fonts on Google Fonts (https://www.google.com/fonts)# All fonts set here will have the following styles:# light | light italic | normal | normal italic | bold | bold italic# Be aware that setting too much fonts will cause site running slowly# ---------------------------------------------------------------# To avoid space between header and sidebar in scheme Pisces / Gemini, Web Safe fonts are recommended for `global` (and `title`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: # Use custom fonts families or not. # Depended options: `external` and `family`. enable: true # Uri of fonts host, e.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: x.x`. Use `em` as unit. Default: 1 (16px) # Global font settings used for all elements inside &lt;body&gt;. global: external: true family: Verdana size: # Font settings for site title (.site-title). title: external: true family: size: # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;). headings: external: true family: size: # Font settings for posts (.post-body). posts: external: true family: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: menlo size: 20 动画 NexT默认是开启了动画效果的,如果不想要,将next/_config.yml下的motion修改为false即可关闭动画,动画有很多值,根据需要配置即可,可多多尝试获取一个自己喜欢的效果 12345678910111213141516171819# Use velocity to animate everything.# For more information: http://velocityjs.orgmotion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn #文章块加载动画 post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn #侧边栏加载动画]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub部署个人博客]]></title>
    <url>%2Fblog%2Fposts%2F3573004847.html</url>
    <content type="text"><![CDATA[准备工作 GitHub账号 要将博客部署到GitHub上,首先我们当然要有一个GitHub的账号呀! 🤣🤣🤣 开始吧!新建仓库点击右上角 New repository 新建一个仓库,仓库名称格式: your GitHub Name.github.io 当然,其实这里的名称是可以随便命名的,只是这样的格式会直接将你的项目部署到根目录下,如果不是这样的格式,后续需要修改_config.yml文件中的url和root字段 12345&gt; #URL&gt; #If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'&gt; url: http://yoursite.com&gt; root: /&gt; 即,如果你的仓库名为blog,那么你的博客域名会是your GitHub Name.github.io/blog这个时候需要就url改为上述域名,同时将root改为/blog/,不然你会发现你的博客没有css效果而且需要手动进入项目的 settings &gt; GitHub Pages 手动选择分支(一般直接选master)启动pages服务 配置Hexo 首先安装git deploy 插件 1npm install hexo-deployer-git --save 修改_config.yml文件的deploy字段部分,填上你的repository地址,分支默认master 1234deploy: type: git repo: &lt;your repository address&gt; branch: master 部署到GitHub 运行命令,hexo会将/public/目录下的文件推送到远程仓库 推送前需要配置SSH KEY,不懂的小伙伴可以自行百度一下(手动偷懒🤪🤪🤪) 1hexo clean &amp;&amp; hexo d -g hexo d -g 和hexo g -d作用相同,表示生成文件之后部署到远程 此时,访问https://your GitHub Name.github.io 就可以看到你的个人博客了…]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建个人博客]]></title>
    <url>%2Fblog%2Fposts%2F3967644193.html</url>
    <content type="text"><![CDATA[前言首先我们需要知道Hexo是什么? ​ Hexo 是一个快速、简洁且高效的博客框架(Hexo官网简介) ​ 具体请戳下面链接了解详情↓↓↓😂 Hexo 中文文档 环境要求开始之前,我们需要检查电脑上是否安装好了以下应用程序 Node.js Git 如果没有安装.点击下面的地址下载安装[Node.js 下载地址 ] [Git 下载地址] 开始吧安装运行Hexo因为国内使用npm速度较慢,推荐使用淘宝npm镜像.(当然,有梯子的小伙伴可以无视 -_- ) 淘宝npm镜像安装1npm install -g cnpm --registry=https://registry.npm.taobao.org 之后文中出现的npm 命令均可使用cnpm 替换. Hexo安装1npm install -g hexo-cli 初始化 &gt; 运行 新建一个文件夹用于存放hexo资源,然后进入,执行初始化hexo命令 123mkdir blog cd bloghexo init 此时,一个简单的博客其实就已经搭建好了. 接下来,看看效果吧, 启动hexo服务 1hexo s 打开 http://localhost:4000/ 即可看到一个简单的博客了.👏👏👏 hexo 常用命令介绍 hexo new : 新建文件命令.会在/source/_post下新建一个.md文件,编辑这个文件写一个新的博文 hexo generate:生成生成静态文件,可简写hexo g hexo server: 启动服务,可简写 hexo s heox deploy: 推送到远程服务器 可简写hexo d hexo clean: 清除缓存文件 (db.json) 和已生成的静态文件 (public) 当你在本地将个人博客搭建起来后,我们就可以试着将博客部署到GitHub上了,这样就能让更多的小伙伴能看到你写的博文了…]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
